C compilation and execution model
--------------------------------------

g++ a.cc ---> to compile c++ file
to get info about a file, use the command file filename(with extension)
to implement virtual memory, paging etc... modern systems hv a MMU(memory mangmnt unit)- something that only intel 80386 and later processors have.
so linux wont work on older systems.             (cc a.c -o abc will save the output to another file abc.)
c compilation is a complex 4 stage process:

a. preprocessing ---> use -E option (cc -E a.c)
b. compilation proper ---> -S option (c code gets converted to assembly code)
c. assembling ----> -c option (a .o file which contains a machine code(MC contains sequence of numbers, each no is an opcode+operands corresponding to its assembly code), but not executed becoz its not yet complete. This MC shud b linked to some other MC files (So called libraries. A library is a precompiled code.)
d.linking (MC gets compiled with other Library such as The Std C Lib.)

without any other option, ie, simply cc a.c executes all 4 stages and generates the output. 
the stage with high prob of error is compilation phase and the least is assembling simply becoz the MC is generated by the compiler.
 
linux command od---> octal dump-- used to display contents of file in diff ways.
"" "" objdump--> an object file is one that contains some MC....(objdump -D a.out---> D for Dis-assembly)
./a.out --> a part of OS called loader will load the MC in a.out to a free block of memory and the control gets transferred to that block of memory

loader will transfer to a C startup function(startup code) which resides in fixed virtual memory location specified by the linux system.
Startup code does some initializations such as setting global variables to zero. Then control is given to the main().


Python compilation and execution model
----------------------------------------

applicable to most dynamically typed langs.

a. .py file gets compiled to a bytecode. (bytecode compilation) byte code looks like MC but doesnot run directly on the OS, for that u need VM.
b. python virtual machine runs(interprets) the bytecode. (similarly to java)


std python implementation is CPython. PyPython- python written in python.

Working of the virtual machine.
---------------------------------------

fundamentally all instructions are converted to corresponding assembly and then to MC.
Two processor Architectures:
a. register machines (almost all register m/c are real m/c.)
b. stack machines   (common for hypothetical m/c) implicitly source and destination of all operations is the stack. Operands will be popped out to operate upon and the result will be pushed back to the stack.

The python VM is a C program. the VM combines the ideas of a hypothetical processor and a program that executes the instructions on the real machine.The python VM hs its own instruction set, opcodes etc....just like a real machine but doesn't exist in hardware.
A .pyc file(bytecode) is stored in disk when we import a module.
For dis-assembly in python we need to import the dis module.

Why python is considerably slow:
a. VM overhead ---> each python bytecode sequence is evaluated by the VM(c program) which in turn is converted to a machine code. This consumes time.
VM overhead can be eliminated to a certain extent by JIT (Just In-time Translation)
b. time overhead (eg python always checks for buffer overflows and generates an error.)

dynamically written programs shud b exhaustively tested...
UNIT TESTING----> write test cases with assert statements.(assert checks whether an expression holds true.)
Profiling----> finding how much time your code consumes.

Find out what is linking and the 2 diff ways of linking??(Static and dynamic linking), linux command type (eg. type vi gives the path to an executable file specified by the vi command), find command
